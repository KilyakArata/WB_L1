package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"
)

func main() {
	// Запрашиваем у пользователя количество воркеров
	fmt.Println("Введите количество воркеров:")
	var n int
	_, err := fmt.Scan(&n)
	if err != nil {
		panic(err) // Завершаем программу в случае ошибки ввода
	}

	// Создаем канал для передачи данных
	a := make(chan int)

	// Создаем контекст, который завершится при получении сигнала прерывания (Ctrl+C)
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop() // Обеспечиваем вызов stop() при завершении функции main для освобождения ресурсов

	// Создаем воркеров
	for i := 1; i <= n; i++ {
		go func(id int, a <-chan int) {
			// Каждый воркер читает данные из канала и выводит их в stdout
			for v := range a {
				fmt.Printf("Воркер %d получил: %d\n", id, v)
			}
		}(i, a) // Передаем id и канал в анонимную функцию, чтобы избежать замыканий
	}

	// Горутина для постоянной записи данных в канал
	go func() {
		i := 0
		for {
			select {
			case <-ctx.Done(): // Если контекст завершен (получен сигнал прерывания)
				return
			default:
				time.Sleep(100 * time.Millisecond) // Задержка для имитации работы
				i++
				a <- i // Записываем данные в канал
			}
		}
	}()

	// Ожидаем завершения контекста (сигнала прерывания)
	<-ctx.Done()

	// Закрываем канал, чтобы воркеры завершили свою работу
	close(a)
}

/*
Использование контекста для обработки сигналов позволяет корректно завершить программу по нажатию Ctrl+C.
Воркеры завершают свою работу, когда канал закрывается, так как чтение из закрытого канала возвращает нулевое значение
и завершает цикл for.Это гарантирует упорядоченное завершение всех горутин и освобождение ресурсов.
*/
